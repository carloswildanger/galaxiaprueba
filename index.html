<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Para Mi Bebe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: white;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 10; cursor: pointer;
            transition: opacity 1s ease;
        }
        #overlay h1 { font-family: sans-serif; font-size: 2rem; text-align: center; pointer-events: none; }
        #overlay p { font-family: sans-serif; font-size: 1rem; margin-top: 10px; opacity: 0.8; pointer-events: none; }
        .heart-beat { animation: beat 1s infinite alternate; }
        @keyframes beat { from { transform: scale(1); } to { transform: scale(1.1); } }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 class="heart-beat">Hola Bebe</h1>
        <h1>Espero te guste</h1>
        <p>(Usa el dedo o mouse para girar y hacer zoom)</p>
    </div>

    <audio id="bgMusic" loop hidden>
        <source src="assets/musica.mp3" type="audio/mpeg">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

        const config = {
            frases: ["TE AMO", "MI VIDA", "ERES MI TODO", "SIEMPRE JUNTOS", "MI LUNA", "MI SOL", "TE ADORO", "SOLO TÚ", "POR SIEMPRE", "MI PERSONA FAVORITA", "JUNTOS", "AMOR ETERNO", "MI FELICIDAD", "TE QUIERO", "CONTIGO SIEMPRE", "ERES MAGIA", "MI UNIVERSO"],
            imagenes: ['assets/foto1.jpg', 'assets/foto2.jpg', 'assets/foto3.jpg', 'assets/foto4.jpg'],
            colorCorazon: 0xff0040,
            colorTexto: 0xffd700,
            velocidadGiro: 0.0015, 
            cantidadEstrellas: 15000,
            cantidadFotos: 100,     
            cantidadFrases: 70,    
            radioGalaxia: 50
        };

        let scene, camera, renderer, controls, heartMesh, composer;
        const floatingGroup = new THREE.Group();
        const starsGroup = new THREE.Group();
        const clock = new THREE.Clock();

        // DEFINIMOS CAPAS: Capa 0 para estela (estrellas), Capa 1 para lo nítido (fotos/texto)
        const EN_ESTELA = 0;
        const SIN_ESTELA = 1;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 80);
            // La cámara debe poder ver ambas capas
            camera.layers.enable(EN_ESTELA);
            camera.layers.enable(SIN_ESTELA);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false; // Importante para renderizar por capas
            document.body.appendChild(renderer.domElement);

            // POST-PROCESAMIENTO solo para la capa de la galaxia
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const afterimagePass = new AfterimagePass(0.88);
            composer.addPass(afterimagePass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.6;

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 2, 200);
            camera.add(pointLight);
            scene.add(camera);

            createHeart();
            createMassiveStarfield();
            loadFloatingContent();

            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('overlay').addEventListener('click', () => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('bgMusic').play();
            });
        }

        function getCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.6)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createHeart() {
            const heartShape = new THREE.Shape();
            heartShape.moveTo(5, 5);
            heartShape.bezierCurveTo(5, 5, 4, 0, 0, 0);
            heartShape.bezierCurveTo(-6, 0, -6, 7, -6, 7);
            heartShape.bezierCurveTo(-6, 11, -3, 15.4, 5, 19);
            heartShape.bezierCurveTo(12, 15.4, 16, 11, 16, 7);
            heartShape.bezierCurveTo(16, 7, 16, 0, 10, 0);
            heartShape.bezierCurveTo(7, 0, 5, 5, 5, 5);

            const geometry = new THREE.ExtrudeGeometry(heartShape, { depth: 4, bevelEnabled: true, bevelSize: 1.5, bevelThickness: 1.5 });
            geometry.center();

            const material = new THREE.MeshBasicMaterial({ color: config.colorCorazon });
            heartMesh = new THREE.Mesh(geometry, material);
            heartMesh.rotation.z = Math.PI;
            
            heartMesh.layers.set(SIN_ESTELA); // El corazón NO tendrá estela
            scene.add(heartMesh);
        }

        function createMassiveStarfield() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const colors = [];
            for (let i = 0; i < config.cantidadEstrellas; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 280;
                const spiralOffset = radius * 0.5 * Math.sin(radius * 0.02 + angle);
                pos.push(Math.cos(angle) * radius + spiralOffset, (Math.random() - 0.5) * 30, Math.sin(angle) * radius + spiralOffset);
                const colorType = Math.random();
                if (colorType < 0.33) colors.push(1, 0.4, 0.8); else if (colorType < 0.66) colors.push(0.7, 0.3, 1); else colors.push(0.4, 0.7, 1); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const mat = new THREE.PointsMaterial({ size: 1.8, vertexColors: true, transparent: true, map: getCircleTexture(), alphaTest: 0.01, depthWrite: false, blending: THREE.AdditiveBlending });

            const stars = new THREE.Points(geo, mat);
            stars.layers.set(EN_ESTELA); // Las estrellas SÍ tendrán estela
            starsGroup.add(stars);
            scene.add(starsGroup);
        }

        function loadFloatingContent() {
            const loader = new THREE.TextureLoader();
            const fontLoader = new FontLoader();
            
            for (let i = 0; i < config.cantidadFotos; i++) {
                const tex = loader.load(config.imagenes[i % config.imagenes.length]);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), mat);
                setRandomPos(mesh, config.radioGalaxia);
                mesh.layers.set(SIN_ESTELA); // Sin estela
                floatingGroup.add(mesh);
            }

            fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                for (let i = 0; i < config.cantidadFrases; i++) {
                    const frase = config.frases[i % config.frases.length];
                    const geo = new TextGeometry(frase, { font: font, size: 2.2, height: 0.2 });
                    geo.center();
                    const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: config.colorTexto }));
                    setRandomPos(mesh, config.radioGalaxia + 10);
                    mesh.layers.set(SIN_ESTELA); // Sin estela
                    floatingGroup.add(mesh);
                }
            });
            scene.add(floatingGroup);
        }

        function setRandomPos(obj, baseRadius) {
            const angle = Math.random() * Math.PI * 2;
            const r = baseRadius + (Math.random() - 0.5) * 50;
            obj.position.set(Math.cos(angle) * r, (Math.random() - 0.5) * 45, Math.sin(angle) * r);
            obj.userData = { offset: Math.random() * 10 };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            controls.update();

            if (heartMesh) {
                heartMesh.scale.setScalar(0.5 + Math.sin(t * 3) * 0.05);
                heartMesh.rotation.y += 0.008;
            }

            floatingGroup.rotation.y += config.velocidadGiro;
            starsGroup.rotation.y += config.velocidadGiro * 0.5;

            floatingGroup.children.forEach(child => {
                child.position.y += Math.sin(t + child.userData.offset) * 0.03;
                child.quaternion.copy(camera.quaternion);
            });

            // --- RENDERIZADO POR CAPAS ---
            renderer.clear();

            // 1. Renderizar Galaxia con Estela (Capa 0)
            camera.layers.set(EN_ESTELA);
            composer.render();

            // 2. Limpiar buffer de profundidad para que las fotos se vean adelante sin estela
            renderer.clearDepth();

            // 3. Renderizar Fotos y Texto nítidos (Capa 1)
            camera.layers.set(SIN_ESTELA);
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>

</html>





