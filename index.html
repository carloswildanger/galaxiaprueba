<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Para Mi Bebe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: white;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 10; cursor: pointer;
            transition: opacity 1s ease;
        }
        #overlay h1 { font-family: sans-serif; font-size: 2rem; text-align: center; pointer-events: none; }
        #overlay p { font-family: sans-serif; font-size: 1rem; margin-top: 10px; opacity: 0.8; pointer-events: none; }
        .heart-beat { animation: beat 1s infinite alternate; }
        @keyframes beat { from { transform: scale(1); } to { transform: scale(1.1); } }
    </style>
</head>
<body>

    <div id="overlay">
        <h1 class="heart-beat">Hola Bebe</h1>
        <h1>Espero te guste</h1>
        <p>(Usa el dedo o mouse para girar y hacer zoom)</p>
    </div>

    <audio id="bgMusic" loop hidden>
        <source src="assets/musica.mp3" type="audio/mpeg">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        // Importamos módulos para el efecto de estela (post-procesamiento)
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

        const config = {
            // Lista más larga de frases. Se repetirán para llenar la galaxia.
            frases: [
                "TE AMO", "MI VIDA", "ERES MI TODO", "SIEMPRE JUNTOS", "MI LUNA", "MI SOL",
                "TE ADORO", "SOLO TÚ", "POR SIEMPRE", "MI PERSONA FAVORITA", "JUNTOS", "AMOR ETERNO",
                "MI FELICIDAD", "TE QUIERO", "CONTIGO SIEMPRE", "ERES MAGIA", "MI UNIVERSO"
            ],
            imagenes: [
                'assets/foto1.jpg', 
                'assets/foto2.jpg', 
                'assets/foto3.jpg',
                'assets/foto4.jpg'
            ],
            colorCorazon: 0xff0040,
            colorTexto: 0xffd700,
            velocidadGiro: 0.0015, 
            cantidadEstrellas: 15000,
            cantidadFotos: 100,     
            cantidadFrases: 100,    
            radioGalaxia: 40
        };

        let scene, camera, renderer, controls, heartMesh, composer;
        const floatingGroup = new THREE.Group();
        const starsGroup = new THREE.Group();
        const clock = new THREE.Clock();

        function init() {
            scene = new THREE.Scene();
            // Niebla ligera para dar profundidad y oscurecer las partículas lejanas
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 70);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Configuración del Efecto de Estela (Afterimage)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // El valor 'damp' controla la longitud de la estela (0.92 es una estela bien marcada)
            const afterimagePass = new AfterimagePass(0.20);
            composer.addPass(afterimagePass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxDistance = 200;
            controls.minDistance = 20;

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(config.colorCorazon, 3, 150);
            scene.add(pointLight);

            createHeart();
            createMassiveStarfield();
            loadFloatingContent();

            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('overlay').addEventListener('click', () => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('bgMusic').play();
            });
        }

        // =============================================================
        // NUEVA FUNCIÓN: Genera una textura circular en memoria
        // =============================================================
        function getCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');

            // Dibujar un círculo blanco con bordes suaves
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');   // Centro blanco sólido
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.8)'); // Mitad semi-transparente
            gradient.addColorStop(1, 'rgba(255,255,255,0)');   // Borde transparente

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        // =============================================================

        function createHeart() {
            const x = 0, y = 0;
            const heartShape = new THREE.Shape();
            heartShape.moveTo( x + 5, y + 5 );
            heartShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );
            heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 );
            heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
            heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );
            heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );
            heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );

            const extrudeSettings = { depth: 4, bevelEnabled: true, bevelSize: 1.5, bevelThickness: 1.5 };
            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            geometry.center();

            const material = new THREE.MeshStandardMaterial({ 
                color: config.colorCorazon,
                emissive: config.colorCorazon,
                emissiveIntensity: 1.5,
                roughness: 0.2,
                metalness: 0.3
            });

            heartMesh = new THREE.Mesh(geometry, material);
            heartMesh.rotation.z = Math.PI;
            scene.add(heartMesh);
        }

        function createMassiveStarfield() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const colors = [];
            for (let i = 0; i < config.cantidadEstrellas; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 250; // Radio más amplio
                const spiralOffset = radius * 0.5 * Math.sin(radius * 0.02 + angle);
                
                // Distribución más aplanada (forma de disco galáctico)
                const x = Math.cos(angle) * radius + spiralOffset;
                const y = (Math.random() - 0.5) * (20 - radius * 0.05); // Menos altura en los bordes
                const z = Math.sin(angle) * radius + spiralOffset;
                pos.push(x, y, z);
                
                // Colores galácticos (rosa, morado, azul)
                const colorType = Math.random();
                if (colorType < 0.33) colors.push(1, 0.4, 0.7); // Rosa
                else if (colorType < 0.66) colors.push(0.6, 0.2, 1); // Morado
                else colors.push(0.3, 0.6, 1); // Azul claro
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // === MODIFICACIÓN AQUÍ ===
            // 1. Generamos la textura circular
            const circleMap = getCircleTexture();

            // 2. Aplicamos la textura al material
            const mat = new THREE.PointsMaterial({ 
                size: 1.5, // Aumentamos el tamaño porque los círculos se ven más chicos que los cuadrados
                vertexColors: true, 
                transparent: true, 
                opacity: 0.9,
                map: circleMap, // ¡Aquí va la textura circular!
                alphaTest: 0.1, // Ayuda a limpiar los bordes transparentes
                depthWrite: false // Mejor rendimiento y visualización para muchas partículas transparentes
            });
            // ==========================

            const stars = new THREE.Points(geo, mat);
            starsGroup.add(stars);
            scene.add(starsGroup);
        }

        function loadFloatingContent() {
            const loader = new THREE.TextureLoader();
            const fontLoader = new FontLoader();
            
            for (let i = 0; i < config.cantidadFotos; i++) {
                const tex = loader.load(config.imagenes[i % config.imagenes.length]);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5, 5), mat);
                setRandomPos(mesh, config.radioGalaxia);
                floatingGroup.add(mesh);
            }

            fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                for (let i = 0; i < config.cantidadFrases; i++) {
                    const frase = config.frases[i % config.frases.length];
                    const geo = new TextGeometry(frase, { font: font, size: 1.8, height: 0.3 });
                    geo.center();
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                        color: config.colorTexto,
                        emissive: config.colorTexto,
                        emissiveIntensity: 1
                    }));
                    setRandomPos(mesh, config.radioGalaxia + 15);
                    floatingGroup.add(mesh);
                }
            });

            scene.add(floatingGroup);
        }

        function setRandomPos(obj, baseRadius) {
            const angle = Math.random() * Math.PI * 2;
            const r = baseRadius + (Math.random() - 0.5) * 40;
            const spiralOffset = r * 0.3 * Math.sin(r * 0.05 + angle);

            obj.position.set(
                Math.cos(angle) * r + spiralOffset,
                (Math.random() - 0.5) * 40,
                Math.sin(angle) * r + spiralOffset
            );
            obj.userData = { speed: 0.003 + Math.random() * 0.008, offset: Math.random() * 10 };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            controls.update();

            if (heartMesh) {
                heartMesh.scale.setScalar(0.5 + Math.sin(t * 3) * 0.03); // Latido suave
                heartMesh.rotation.y += 0.005;
            }

            floatingGroup.rotation.y += config.velocidadGiro;
            starsGroup.rotation.y += config.velocidadGiro * 0.7;

            floatingGroup.children.forEach(child => {
                child.position.y += Math.sin(t + child.userData.offset) * 0.03;
                child.quaternion.copy(camera.quaternion);
            });

            composer.render();
        }

        init();
        animate();
    </script>
</body>
</html>